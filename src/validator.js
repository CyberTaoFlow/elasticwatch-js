// Generated by CoffeeScript 1.10.0
(function() {
  var Validator, log,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  log = require("loglevel");


  /**
   * The Validator takes an elasticsearch query result and compares it to a
   * defined expectation (default is "value is within range of min/max for n
   * times").
   *
   * @class   Validator
   */

  module.exports = Validator = (function() {

    /**
     * Create a new Validator with the given options.
     * @constructor
     * @param  fieldName {String}  name of the result field (key) to use as comaprison value
     * @param  min       {int}     minimum allowed value (= lower bound)
     * @param  max       {int}     maximum allowed value (= upper bound)
     * @param  tolerance {int}     maximum allowed number of consecutive values that do not match the expectation
     */
    function Validator(fieldName, min, max, tolerance) {
      this.fieldName = fieldName;
      this.min = min;
      this.max = max;
      this.tolerance = tolerance;
      this.validate = bind(this.validate, this);
      this.fails = [];
      if (!this.fieldName || this.min === null || this.max === null || this.tolerance === null) {
        throw new Error("invalid number of options");
      }
    }


    /*
     * Validate the given elasticsearch query result against the expectation.
     *
     * @method validate
     * @param  data  {Object}  elasticsearch query result
     */

    Validator.prototype.validate = function(data) {
      var hit, i, len, ref, val;
      if (!data) {
        return false;
      } else {
        this.fails = [];
        ref = data.hits.hits;
        for (i = 0, len = ref.length; i < len; i++) {
          hit = ref[i];
          val = hit._source[this.fieldName];
          log.debug("Validator.validate: val " + val);
          if ((this.max && val > this.max) || (this.min && val < this.min)) {
            log.debug("Validator.validate: exceeds range");
            this.fails.push(val);
          } else {
            this.fails.length = 0;
          }
          if (this.fails.length > this.tolerance) {
            log.debug("Validator.validate: more than " + this.tolerance + " consecutive fails occured");
            return false;
          }
        }
      }
      return true;
    };


    /**
     * Return human readable error message describing alarm reason. Empty if no
     * validation failed yet.
     *
     * @method getMessage
     * @return {String}
     */

    Validator.prototype.getMessage = function() {
      return "'" + this.fieldName + "' outside range '" + this.min + "-" + this.max + "' for '" + (this.tolerance + 1) + "' consecutive times: '" + (this.fails.join(',')) + "'";
    };

    return Validator;

  })();

}).call(this);
