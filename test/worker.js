// Generated by CoffeeScript 1.10.0
(function() {
  var Worker, assert, httpMock, httpResponseMock, loglevelMock, mockery, validatorMock, worker;

  mockery = require("mockery");

  assert = require("chai").assert;

  worker = [][0];

  loglevelMock = {
    debug: function(str) {
      return this.strDebug = str;
    },
    error: function(str) {
      return this.strError = str;
    }
  };

  httpResponseMock = {
    statusCode: 200,
    responseData: JSON.stringify({
      foo: "bar"
    }),
    on: function(name, callback) {
      if (name === "data") {
        return callback(httpResponseMock.responseData);
      } else if (name === "end") {
        return callback();
      }
    }
  };

  httpMock = {
    request: function(options, callback) {
      this.requestOptions = options;
      return {
        on: function() {},
        end: function() {
          return callback(httpResponseMock);
        },
        write: (function(_this) {
          return function(data) {
            return httpMock.writeData = data;
          };
        })(this)
      };
    }
  };

  validatorMock = {
    validate: function(data) {
      return true;
    },
    getMessage: function() {
      return "testmessage";
    }
  };

  mockery.enable({
    useCleanCache: true
  });

  mockery.registerMock("loglevel", loglevelMock);

  mockery.registerMock("http", httpMock);

  mockery.registerMock("./validator", validatorMock);

  mockery.registerAllowables(["../src/worker", "events"]);

  Worker = require("../src/worker");

  describe("Worker", function() {
    describe("constructor", function() {
      it("should have the assigned id", function() {
        return assert.equal(new Worker("testworker", "host", 9200, "/_all", {}, validatorMock).id, "testworker", "id property should equal the constructor's first argument");
      });
      return it("should break if any argument of [id,host,port,path,query] is missing", function() {
        assert["throw"]((function() {
          return new Worker(null, "host", 9200, "/_all", {}, validatorMock);
        }), Error, "invalid number of options");
        assert["throw"]((function() {
          return new Worker("testworker", null, 9200, "/_all", {}, validatorMock);
        }), Error, "invalid number of options");
        assert["throw"]((function() {
          return new Worker("testworker", "host", null, "/_all", {}, validatorMock);
        }), Error, "invalid number of options");
        assert["throw"]((function() {
          return new Worker("testworker", "host", 9200, null, {}, validatorMock);
        }), Error, "invalid number of options");
        assert["throw"]((function() {
          return new Worker("testworker", "host", 9200, "/_all", null, validatorMock);
        }), Error, "invalid number of options");
        return assert["throw"]((function() {
          return new Worker("testworker", "host", 9200, "/_all", {}, null);
        }), Error, "invalid number of options");
      });
    });
    describe("start", function() {
      it("should establish an http connection using the supplied options", function() {
        new Worker("testworker", "testhost", 9200, "/_all", {
          foo: "bar"
        }, validatorMock).start();
        assert.equal(httpMock.requestOptions.host, "testhost");
        assert.equal(httpMock.requestOptions.port, 9200);
        return assert.equal(httpMock.requestOptions.path, "/_all/_search");
      });
      return it("should send the stringified query through http", function() {
        var queryMock;
        queryMock = {
          foo: "bar"
        };
        new Worker("testworker", "testhost", 9200, "/_all", queryMock, validatorMock).start();
        return assert.equal(httpMock.writeData, JSON.stringify({
          query: queryMock
        }));
      });
    });
    describe("onResponse", function() {
      worker = [][0];
      beforeEach(function() {
        return worker = new Worker("testworker", "testhost", 9200, "/_all", {
          foo: "bar"
        }, validatorMock);
      });
      return it("should emit an 'alarm' event when response status isnt 200", function(done) {
        httpResponseMock.statusCode = 400;
        worker.on("alarm", function(msg) {
          assert.include(msg, Worker.ResultCodes.NotFound.label);
          done();
          return worker.off("alarm");
        });
        return worker.start();
      });
    });
    return describe("handleResponseData", function() {
      var ref, resultStub;
      ref = [], worker = ref[0], resultStub = ref[1];
      beforeEach(function() {
        worker = new Worker("testworker", "testhost", 9200, "/_all", {
          foo: "bar"
        }, validatorMock);
        return resultStub = {
          hits: {
            total: 1,
            hits: [
              {
                _source: {
                  prop: 1
                }
              }
            ]
          }
        };
      });
      it("should emit an 'alarm' event when data validation fails due to invalid data", function(done) {
        worker.on("alarm", function(msg) {
          assert.include(msg, Worker.ResultCodes.InvalidResponse.label);
          return done();
        });
        return worker.handleResponseData({});
      });
      it("should emit an 'alarm' event when handleResponseData didn't receive any results", function(done) {
        worker.on("alarm", function(msg) {
          assert.include(msg, Worker.ResultCodes.NoResults.label);
          return done();
        });
        return worker.handleResponseData({
          hits: {
            total: 0,
            hits: []
          }
        });
      });
      it("should emit an 'alarm' event when data validation fails", function(done) {
        validatorMock.validate = (function() {
          return false;
        });
        worker.on("alarm", function(msg) {
          assert.include(msg, Worker.ResultCodes.ValidationFailed.label);
          return done();
        });
        return worker.handleResponseData(resultStub);
      });
      return it("should simply return true if data validation succeeds", function() {
        validatorMock.validate = (function() {
          return true;
        });
        return assert.isTrue(worker.handleResponseData(resultStub));
      });
    });
  });

}).call(this);
